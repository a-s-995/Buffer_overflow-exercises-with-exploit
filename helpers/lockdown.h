#ifndef _LOCKDOWN_H
#define _LOCKDOWN_H
// For additional info about seccomps, see:
// * https://wiki.mozilla.org/Security/Sandbox/Seccomp
// * https://eigenstate.org/notes/seccomp

#include <stddef.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

//                                                                          struct seccomp_data {
#define SYSCALL_nr (offsetof(struct seccomp_data, nr))                //      int nr;
#define ARCH_FIELD (offsetof(struct seccomp_data, arch))              //      __u32 arch;
#define IP_FIELD (offsetof(struct seccomp_data, instruction_pointer)) //      __u64 instruction_pointer;
#define ARG0_FIELD (offsetof(struct seccomp_data, args[0]))           //      __u64 args[6];
//                                                                          };

#define KILL_PROCESS()                          /***/ \
    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL) /***/

// A = [idx]
#define LOAD_A(idx)                         /***/ \
    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, idx) /***/
// BPF_STMT(BPF_LD + BPF_W + BPF_ABS, SYSCALL_nr) /***/

//  if (A == SYS_##syscall)
//      return SECCOMP_RET_ALLOW
#define ALLOW_SYSCALL(syscall)                                /***/ \
    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SYS_##syscall, 0, 1), /***/ \
        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)          /***/

//  if (A == SYS_##syscall && args[0] == arg0)
//      return SECCOMP_RET_ALLOW
#define ALLOW_SYSCALL_ARG0(syscall, arg0)                     /***/ \
    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, SYS_##syscall, 0, 3), /***/ \
        LOAD_A(ARG0_FIELD),                                   /***/ \
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arg0, 0, 1),      /***/ \
        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),         /***/ \
        LOAD_A(SYSCALL_nr)                                    /***/

//  if ([ARCH_FIELD] != AUDIT_ARCH_X86_64)
//      return SECCOMP_RET_KILL
#define CHECK_ARCHITECTURE()                                          /***/ \
    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, ARCH_FIELD),                   /***/ \
        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0), /***/ \
        KILL_PROCESS()                                                /***/

struct sock_filter filter[] = {
    CHECK_ARCHITECTURE(),

    //  A = syscall_nr
    LOAD_A(SYSCALL_nr),

    ALLOW_SYSCALL(exit),          /* for exit() */
    ALLOW_SYSCALL(exit_group),    /* for exit() */
    ALLOW_SYSCALL(brk),           /* for malloc() */
    ALLOW_SYSCALL(mmap),          /* for malloc() */
    ALLOW_SYSCALL(munmap),        /* for free() */
    ALLOW_SYSCALL(fstat),         /* for printf() */
    ALLOW_SYSCALL_ARG0(write, 1), /* for printf() */
    ALLOW_SYSCALL_ARG0(read, 0),  /* for fgets(), scanf(), etc. */
    ALLOW_SYSCALL_ARG0(lseek, 0), /* for flushing at exit() */
    ALLOW_SYSCALL(time),          /* for statically linked libc() */

#ifdef ALLOW_FILE_READ
    ALLOW_SYSCALL(open),
    ALLOW_SYSCALL(openat),
    ALLOW_SYSCALL(close),
    ALLOW_SYSCALL(read),
#endif /* ALLOW_FILE_READ */

    /* and if we don't match above, die */
    KILL_PROCESS(),
};

struct sock_fprog filterprog = {
    .len = sizeof(filter) / sizeof(filter[0]),
    .filter = filter,
};

// from: https://cs.chromium.org/chromium/src/sandbox/linux/seccomp-bpf/sandbox_bpf.cc
// Check if the kernel supports seccomp-filter prctl().
int have_seccomp_support()
{
    errno = 0;
    const int res = prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL);
    return res == -1 && EFAULT == errno;
}

void lockdown_program()
{
    /* Forbid future setting of new privileges; i.e., don't to allow reverting sandbox */
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0))
    {
        puts("ERROR: Could not lockdown");
        exit(1);
    }
    if (!have_seccomp_support())
    {
        // Allow running the program even without seccomp filter support.
        // This is to allow testing on noncompatible machines.
        // On the server, seccomp filters are supported
        puts("ERROR:   Seccomp not supported");
        puts("WARNING: Behavior will vary between the server and local versions");
        return;
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1)
    {
        puts("ERROR:   Could not lockdown");
        exit(1);
    }
}

#endif /* _LOCKDOWN_H */