#ifndef _SECURE_STRING
#define _SECURE_STRING

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "printer.h"

#define MAX_STATIC_LENGTH 32
#define MAX_DYNAMIC_LENGTH 256
#define MAGIC_VALUE 0xdeadbeefdeadc0de
#define CHECK_MAGIC()                                   \
    do                                                  \
    {                                                   \
        if (sec_str->magic != MAGIC_VALUE)              \
        {                                               \
            printf("ERROR: Heap overflow detected!\n"); \
            exit(1);                                    \
        }                                               \
    } while (0)

typedef union _SafeData {
    char fixed[8];
    char *dynamic;
} SafeData;

typedef struct _SafeString
{
    uint64_t is_fixed;
    uint64_t length;
    uint64_t magic;
    SafeData data;
} SafeString;

//##############################################################################
// Helper functions declarations
//##############################################################################
SafeString *SafeString_init();
void SafeString_readline(SafeString *sec_str);
char *SafeString_getdata(SafeString *sec_str) __attribute__((always_inline));

//##############################################################################
// Helper functions Definitions
//##############################################################################
SafeString *SafeString_init()
{
    SafeString *sec_str = (SafeString *)malloc(MAX_STATIC_LENGTH);
    sec_str->is_fixed = 1;
    sec_str->length = MAX_STATIC_LENGTH;
    sec_str->magic = MAGIC_VALUE; // If changed -> there was overflow
    sec_str->data.dynamic = NULL;
    return sec_str;
}

void SafeString_readline(SafeString *sec_str)
{
    char tmp[MAX_DYNAMIC_LENGTH] = {0};

    sec_str->data.dynamic = NULL;

    best_gets_v2(tmp, MAX_DYNAMIC_LENGTH);
    int read_size = strnlen(tmp, MAX_DYNAMIC_LENGTH); // length without \0

    if (read_size < MAX_STATIC_LENGTH)
    {
        sec_str->is_fixed = 1;
        sec_str->length = read_size + 1; // including the null terminator
        strncpy(sec_str->data.fixed, tmp, read_size);
        sec_str->data.fixed[read_size] = '\0';
    }
    else
    {
        sec_str->is_fixed = 0;
        sec_str->data.dynamic = (char *)malloc(MAX_DYNAMIC_LENGTH);
        strncpy(sec_str->data.dynamic, tmp, read_size);
        sec_str->length = read_size;
        sec_str->data.dynamic[read_size] = '\0';
    }
    CHECK_MAGIC();
}
inline char *SafeString_getdata(SafeString *sec_str)
{
    CHECK_MAGIC();
    return sec_str->is_fixed ? sec_str->data.fixed : sec_str->data.dynamic;
}

#endif /* _SECURE_STRING */